{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\n/**\n * vue-meta v3.0.0-alpha.2\n * (c) 2021\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\nimport { markRaw, h, getCurrentInstance, isProxy, watch, inject, defineComponent, reactive, onUnmounted, Teleport } from 'vue';\nconst resolveOption = predicament => (options, contexts) => {\n  let resolvedIndex = -1;\n  contexts.reduce((acc, context, index) => {\n    const retval = predicament(acc, context);\n    if (retval !== acc) {\n      resolvedIndex = index;\n      return retval;\n    }\n    return acc;\n  }, undefined);\n  if (resolvedIndex > -1) {\n    return options[resolvedIndex];\n  }\n};\nfunction setup(context) {\n  let depth = 0;\n  if (context.vm) {\n    let {\n      vm\n    } = context;\n    do {\n      if (vm.parent) {\n        depth++;\n        vm = vm.parent;\n      }\n    } while (vm && vm.parent && vm !== vm.root);\n  }\n  context.depth = depth;\n}\nconst resolve = resolveOption((acc, context) => {\n  const {\n    depth\n  } = context;\n  if (!acc || depth > acc) {\n    return acc;\n  }\n});\nvar deepest = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setup: setup,\n  resolve: resolve\n});\nconst defaultConfig = {\n  body: {\n    tag: 'script',\n    to: 'body'\n  },\n  base: {\n    valueAttribute: 'href'\n  },\n  charset: {\n    tag: 'meta',\n    nameless: true,\n    valueAttribute: 'charset'\n  },\n  description: {\n    tag: 'meta'\n  },\n  og: {\n    group: true,\n    namespacedAttribute: true,\n    tag: 'meta',\n    keyAttribute: 'property'\n  },\n  twitter: {\n    group: true,\n    namespacedAttribute: true,\n    tag: 'meta'\n  },\n  htmlAttrs: {\n    attributesFor: 'html'\n  },\n  headAttrs: {\n    attributesFor: 'head'\n  },\n  bodyAttrs: {\n    attributesFor: 'body'\n  }\n};\n\n/*\r\n * This is a fixed config for real HTML tags\r\n */\nconst tags = {\n  title: {\n    attributes: false\n  },\n  base: {\n    contentAsAttribute: true,\n    attributes: ['href', 'target']\n  },\n  meta: {\n    contentAsAttribute: true,\n    keyAttribute: 'name',\n    attributes: ['content', 'name', 'http-equiv', 'charset']\n  },\n  link: {\n    contentAsAttribute: true,\n    attributes: ['href', 'crossorigin', 'rel', 'media', 'integrity', 'hreflang', 'type', 'referrerpolicy', 'sizes', 'imagesrcset', 'imagesizes', 'as', 'color']\n  },\n  style: {\n    attributes: ['media']\n  },\n  script: {\n    attributes: ['src', 'type', 'nomodule', 'async', 'defer', 'crossorigin', 'integrity', 'referrerpolicy']\n  },\n  noscript: {\n    attributes: false\n  }\n};\nfunction getTagConfigItem(tagOrName, key) {\n  for (const name of tagOrName) {\n    const tag = tags[name];\n    if (name && tag) {\n      return tag[key];\n    }\n  }\n}\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\nprocess.env.NODE_ENV !== 'production' ? Object.freeze({}) : {};\nprocess.env.NODE_ENV !== 'production' ? Object.freeze([]) : [];\nconst isArray = Array.isArray;\nconst isFunction = val => typeof val === 'function';\nconst isString = val => typeof val === 'string';\nconst isObject = val => val !== null && typeof val === 'object';\nconst objectToString = Object.prototype.toString;\nconst toTypeString = value => objectToString.call(value);\nconst isPlainObject = val => toTypeString(val) === '[object Object]';\n\n// https://github.com/microsoft/TypeScript/issues/1863\nconst IS_PROXY = Symbol('kIsProxy');\nconst PROXY_SOURCES = Symbol('kProxySources');\nconst PROXY_TARGET = Symbol('kProxyTarget');\nconst RESOLVE_CONTEXT = Symbol('kResolveContext');\n\n// See: https://github.com/vuejs/vue-next/blob/08b4e8815da4e8911058ccbab986bea6365c3352/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts\nfunction clone(v) {\n  if (isArray(v)) {\n    return v.map(clone);\n  }\n  if (isObject(v)) {\n    const res = {};\n    for (const key in v) {\n      // never clone the context\n      if (key === 'context') {\n        res[key] = v[key];\n      } else {\n        res[key] = clone(v[key]);\n      }\n    }\n    return res;\n  }\n  return v;\n}\nconst pluck = (collection, key, callback) => {\n  const plucked = [];\n  for (const row of collection) {\n    if (key in row) {\n      plucked.push(row[key]);\n      if (callback) {\n        callback(row);\n      }\n    }\n  }\n  return plucked;\n};\nconst allKeys = (source, ...sources) => {\n  const keys = source ? Object.keys(source) : [];\n  if (sources) {\n    for (const source of sources) {\n      if (!source || !isObject(source)) {\n        continue;\n      }\n      for (const key in source) {\n        if (!keys.includes(key)) {\n          keys.push(key);\n        }\n      }\n    }\n  }\n  // TODO: add check for consistent types for each key (dev only)\n  return keys;\n};\nconst recompute = (context, sources, target, path = []) => {\n  if (!path.length) {\n    if (!target) {\n      target = context.active;\n    }\n    if (!sources) {\n      sources = context.sources;\n    }\n  }\n  if (!target || !sources) {\n    return;\n  }\n  const keys = allKeys(...sources);\n  // Clean up properties that dont exists anymore\n  const targetKeys = Object.keys(target);\n  for (const key of targetKeys) {\n    if (!keys.includes(key)) {\n      delete target[key];\n    }\n  }\n  for (const key of keys) {\n    // This assumes consistent types usages for keys across sources\n    if (isPlainObject(sources[0][key])) {\n      if (!target[key]) {\n        target[key] = {};\n      }\n      const keySources = [];\n      for (const source of sources) {\n        if (key in source) {\n          keySources.push(source[key]);\n        }\n      }\n      recompute(context, keySources, target[key], [...path, key]);\n      continue;\n    }\n    // Ensure the target is an array if source is an array and target is empty\n    if (!target[key] && isArray(sources[0][key])) {\n      target[key] = [];\n    }\n    const keyContexts = [];\n    const keySources = pluck(sources, key, source => keyContexts.push(source[RESOLVE_CONTEXT]));\n    let resolved = context.resolve(keySources, keyContexts, target[key], key, path);\n    if (isPlainObject(resolved)) {\n      resolved = clone(resolved);\n    }\n    // console.log('RESOLVED', key, resolved, 'was', target[key])\n    target[key] = resolved;\n  }\n};\nconst createProxy = (context, target, resolveContext, pathSegments = []) => {\n  const handler = createHandler(context, resolveContext, pathSegments);\n  const proxy = markRaw(new Proxy(target, handler));\n  if (!pathSegments.length && context.sources) {\n    context.sources.push(proxy);\n  }\n  return proxy;\n};\nconst createHandler = (context, resolveContext, pathSegments = []) => ({\n  get: (target, key, receiver) => {\n    if (key === IS_PROXY) {\n      return true;\n    }\n    if (key === PROXY_SOURCES) {\n      return context.sources;\n    }\n    if (key === PROXY_TARGET) {\n      return target;\n    }\n    if (key === RESOLVE_CONTEXT) {\n      return resolveContext;\n    }\n    let value = Reflect.get(target, key, receiver);\n    if (!isObject(value)) {\n      return value;\n    }\n    if (!value[IS_PROXY]) {\n      const keyPath = [...pathSegments, key];\n      value = createProxy(context, value, resolveContext, keyPath);\n      target[key] = value;\n    }\n    return value;\n  },\n  set: (target, key, value) => {\n    const success = Reflect.set(target, key, value);\n    // console.warn(success, 'PROXY SET\\nkey:', key, '\\npath:', pathSegments, '\\ntarget:', isArray(target), target, '\\ncontext:\\n', context)\n    if (success) {\n      const isArrayItem = isArray(target);\n      let hasArrayParent = false;\n      let {\n        sources: proxies,\n        active\n      } = context;\n      let activeSegmentKey;\n      let index = 0;\n      for (const segment of pathSegments) {\n        proxies = pluck(proxies, segment);\n        if (isArrayItem && index === pathSegments.length - 1) {\n          activeSegmentKey = segment;\n          break;\n        }\n        if (isArray(active)) {\n          hasArrayParent = true;\n        }\n        active = active[segment];\n        index++;\n      }\n      if (hasArrayParent) {\n        // TODO: fix that we dont have to recompute the full merged object\n        // we should only have to recompute the branch that has changed\n        // but there is an issue here with supporting both arrays of strings\n        // as collections (parent vs parent of parent we need to trigger the\n        // update from)\n        recompute(context);\n        return success;\n      }\n      let keyContexts = [];\n      let keySources;\n      if (isArrayItem) {\n        keySources = proxies;\n        keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\n      } else {\n        keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\n      }\n      let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\n      // Ensure to clone if value is an object, cause sources is an array of\n      // the sourceProxies not the sources so we could trigger an endless loop when\n      // updating a prop on an obj as the prop on the active object refers to\n      // a prop on a proxy\n      if (isPlainObject(resolved)) {\n        resolved = clone(resolved);\n      }\n      //      console.log('SET VALUE', isArrayItem, key, '\\nresolved:\\n', resolved, '\\nsources:\\n', context.sources, '\\nactive:\\n', active, Object.keys(active))\n      if (isArrayItem && activeSegmentKey) {\n        active[activeSegmentKey] = resolved;\n      } else {\n        active[key] = resolved;\n      }\n    }\n    //    console.log('CONTEXT.ACTIVE', context.active, '\\nparent:\\n', target)\n    return success;\n  },\n  deleteProperty: (target, key) => {\n    const success = Reflect.deleteProperty(target, key);\n    //    console.warn('PROXY DELETE\\nkey:', key, '\\npath:', pathSegments, '\\nparent:', isArray(target), target)\n    if (success) {\n      const isArrayItem = isArray(target);\n      let activeSegmentKey;\n      let proxies = context.sources;\n      let active = context.active;\n      let index = 0;\n      for (const segment of pathSegments) {\n        proxies = proxies.map(proxy => proxy[segment]);\n        if (isArrayItem && index === pathSegments.length - 1) {\n          activeSegmentKey = segment;\n          break;\n        }\n        active = active[segment];\n        index++;\n      }\n      // Check if the key still exists in one of the sourceProxies,\n      // if so resolve the new value, if not remove the key\n      if (proxies.some(proxy => key in proxy)) {\n        let keyContexts = [];\n        let keySources;\n        if (isArrayItem) {\n          keySources = proxies;\n          keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\n        } else {\n          keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\n        }\n        let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\n        if (isPlainObject(resolved)) {\n          resolved = clone(resolved);\n        }\n        //        console.log('SET VALUE', resolved)\n        if (isArrayItem && activeSegmentKey) {\n          active[activeSegmentKey] = resolved;\n        } else {\n          active[key] = resolved;\n        }\n      } else {\n        delete active[key];\n      }\n    }\n    return success;\n  }\n});\nconst createMergedObject = (resolve, active = {}) => {\n  const sources = [];\n  if (!active) {\n    active = {};\n  }\n  const context = {\n    active,\n    resolve,\n    sources\n  };\n  const compute = () => recompute(context);\n  return {\n    context,\n    compute,\n    addSource: (source, resolveContext, recompute = false) => {\n      const proxy = createProxy(context, source, resolveContext || {});\n      if (recompute) {\n        compute();\n      }\n      return proxy;\n    },\n    delSource: (sourceOrProxy, recompute = true) => {\n      const index = sources.findIndex(src => src === sourceOrProxy || src[PROXY_TARGET] === sourceOrProxy);\n      if (index > -1) {\n        sources.splice(index, 1);\n        if (recompute) {\n          compute();\n        }\n        return true;\n      }\n      return false;\n    }\n  };\n};\nfunction renderMeta(context, key, data, config) {\n  // console.info('renderMeta', key, data, config)\n  if ('attributesFor' in config) {\n    return renderAttributes(context, key, data, config);\n  }\n  if ('group' in config) {\n    return renderGroup(context, key, data, config);\n  }\n  return renderTag(context, key, data, config);\n}\nfunction renderGroup(context, key, data, config) {\n  // console.info('renderGroup', key, data, config)\n  if (isArray(data)) {\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.warn('Specifying an array for group properties isnt supported');\n    }\n    // config.attributes = getConfigKey([key, config.tag], 'attributes', config)\n    return [];\n  }\n  return Object.keys(data).map(childKey => {\n    const groupConfig = {\n      group: key,\n      data\n    };\n    if (config.namespaced) {\n      groupConfig.tagNamespace = config.namespaced === true ? key : config.namespaced;\n    } else if (config.namespacedAttribute) {\n      const namespace = config.namespacedAttribute === true ? key : config.namespacedAttribute;\n      groupConfig.fullName = `${namespace}:${childKey}`;\n      groupConfig.slotName = `${namespace}(${childKey})`;\n    }\n    return renderTag(context, key, data[childKey], config, groupConfig);\n  }).flat();\n}\nfunction renderTag(context, key, data, config = {}, groupConfig) {\n  // console.info('renderTag', key, data, config, groupConfig)\n  const contentAttributes = ['content', 'json', 'rawContent'];\n  const getTagConfig = key => getTagConfigItem([tag, config.tag], key);\n  if (isArray(data)) {\n    return data.map(child => {\n      return renderTag(context, key, child, config, groupConfig);\n    }).flat();\n  }\n  const {\n    tag = config.tag || key\n  } = data;\n  let content = '';\n  let hasChilds = false;\n  let isRaw = false;\n  if (isString(data)) {\n    content = data;\n  } else if (data.children && isArray(data.children)) {\n    hasChilds = true;\n    content = data.children.map(child => {\n      const data = renderTag(context, key, child, config, groupConfig);\n      if (isArray(data)) {\n        return data.map(({\n          vnode\n        }) => vnode);\n      }\n      return data.vnode;\n    });\n  } else {\n    let i = 0;\n    for (const contentAttribute of contentAttributes) {\n      if (!content && data[contentAttribute]) {\n        if (i === 1) {\n          content = JSON.stringify(data[contentAttribute]);\n        } else {\n          content = data[contentAttribute];\n        }\n        isRaw = i > 1;\n        break;\n      }\n      i++;\n    }\n  }\n  const fullName = groupConfig && groupConfig.fullName || key;\n  const slotName = groupConfig && groupConfig.slotName || key;\n  let {\n    attrs: attributes\n  } = data;\n  if (!attributes && typeof data === 'object') {\n    attributes = {\n      ...data\n    };\n    delete attributes.tag;\n    delete attributes.children;\n    delete attributes.to;\n    // cleanup all content attributes\n    for (const attr of contentAttributes) {\n      delete attributes[attr];\n    }\n  } else if (!attributes) {\n    attributes = {};\n  }\n  if (hasChilds) {\n    content = getSlotContent(context, slotName, content, data);\n  } else {\n    const contentAsAttribute = !!getTagConfig('contentAsAttribute');\n    let {\n      valueAttribute\n    } = config;\n    if (!valueAttribute && contentAsAttribute) {\n      const [tagAttribute] = getTagConfig('attributes');\n      valueAttribute = isString(contentAsAttribute) ? contentAsAttribute : tagAttribute;\n    }\n    if (!valueAttribute) {\n      content = getSlotContent(context, slotName, content, data);\n    } else {\n      const {\n        nameless,\n        keyAttribute\n      } = config;\n      if (!nameless) {\n        if (keyAttribute) {\n          attributes[keyAttribute] = fullName;\n        }\n      }\n      attributes[valueAttribute] = getSlotContent(context, slotName, attributes[valueAttribute] || content, groupConfig);\n      content = '';\n    }\n  }\n  const finalTag = groupConfig && groupConfig.tagNamespace ? `${groupConfig.tagNamespace}:${tag}` : tag;\n  // console.info('FINAL TAG', finalTag)\n  // console.log('      ATTRIBUTES', attributes)\n  // console.log('      CONTENT', content)\n  // // console.log(data, attributes, config)\n  if (isRaw && content) {\n    attributes.innerHTML = content;\n  }\n  // Ignore empty string content\n  const vnode = h(finalTag, attributes, content || undefined);\n  return {\n    to: data.to,\n    vnode\n  };\n}\nfunction renderAttributes(context, key, data, config) {\n  // console.info('renderAttributes', key, data, config)\n  const {\n    attributesFor\n  } = config;\n  if (!attributesFor) {\n    return;\n  }\n  {\n    // render attributes in a placeholder vnode so Vue\n    // will render the string for us\n    return {\n      to: '',\n      vnode: h(`ssr-${attributesFor}`, data)\n    };\n  }\n}\nfunction getSlotContent({\n  metainfo,\n  slots\n}, slotName, content, groupConfig) {\n  const slot = slots && slots[slotName];\n  if (!slot || !isFunction(slot)) {\n    return content;\n  }\n  const slotScopeProps = {\n    content,\n    metainfo\n  };\n  if (groupConfig && groupConfig.group) {\n    const {\n      group,\n      data\n    } = groupConfig;\n    slotScopeProps[group] = data;\n  }\n  const slotContent = slot(slotScopeProps);\n  if (slotContent && slotContent.length) {\n    const {\n      children\n    } = slotContent[0];\n    return children ? children.toString() : '';\n  }\n  return content;\n}\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nconst PolySymbol = name =>\n// vm = vue meta\nhasSymbol ? Symbol(process.env.NODE_ENV !== 'production' ? '[vue-meta]: ' + name : name) : (process.env.NODE_ENV !== 'production' ? '[vue-meta]: ' : '_vm_') + name;\nconst metaActiveKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'meta_active' : 'ma');\n\n/**\r\n * Apply the differences between newSource & oldSource to target\r\n */\nfunction applyDifference(target, newSource, oldSource) {\n  for (const key in newSource) {\n    if (!(key in oldSource)) {\n      target[key] = newSource[key];\n      continue;\n    }\n    // We dont care about nested objects here , these changes\n    // should already have been tracked by the MergeProxy\n    if (isObject(target[key])) {\n      continue;\n    }\n    if (newSource[key] !== oldSource[key]) {\n      target[key] = newSource[key];\n    }\n  }\n  for (const key in oldSource) {\n    if (!(key in newSource)) {\n      delete target[key];\n    }\n  }\n}\nfunction getCurrentManager(vm) {\n  if (!vm) {\n    vm = getCurrentInstance() || undefined;\n  }\n  if (!vm) {\n    return undefined;\n  }\n  return vm.appContext.config.globalProperties.$metaManager;\n}\nfunction useMeta(source, manager) {\n  const vm = getCurrentInstance() || undefined;\n  if (!manager && vm) {\n    manager = getCurrentManager(vm);\n  }\n  if (!manager) {\n    throw new Error('No manager or current instance');\n  }\n  if (isProxy(source)) {\n    watch(source, (newSource, oldSource) => {\n      // We only care about first level props, second+ level will already be changed by the merge proxy\n      applyDifference(metaProxy.meta, newSource, oldSource);\n    });\n    source = source.value;\n  }\n  const metaProxy = manager.addMeta(source, vm);\n  return metaProxy;\n}\nfunction useActiveMeta() {\n  return inject(metaActiveKey);\n}\nconst MetainfoImpl = defineComponent({\n  name: 'Metainfo',\n  inheritAttrs: false,\n  setup(_, {\n    slots\n  }) {\n    return () => {\n      const manager = getCurrentManager();\n      if (!manager) {\n        return;\n      }\n      return manager.render({\n        slots\n      });\n    };\n  }\n});\nconst Metainfo = MetainfoImpl;\nconst ssrAttribute = 'data-vm-ssr';\nconst active = reactive({});\nfunction addVnode(teleports, to, vnodes) {\n  const nodes = isArray(vnodes) ? vnodes : [vnodes];\n  if (!to.endsWith('Attrs')) {\n    nodes.forEach(vnode => {\n      if (!vnode.props) {\n        vnode.props = {};\n      }\n      vnode.props[ssrAttribute] = true;\n    });\n  }\n  if (!teleports[to]) {\n    teleports[to] = [];\n  }\n  teleports[to].push(...nodes);\n}\nconst createMetaManager = (config, resolver) => MetaManager.create(config, resolver);\nclass MetaManager {\n  constructor(config, target, resolver) {\n    this.ssrCleanedUp = false;\n    this.config = config;\n    this.target = target;\n    if (resolver && 'setup' in resolver && isFunction(resolver.setup)) {\n      this.resolver = resolver;\n    }\n  }\n  install(app) {\n    app.component('Metainfo', Metainfo);\n    app.config.globalProperties.$metaManager = this;\n    app.provide(metaActiveKey, active);\n  }\n  addMeta(metadata, vm) {\n    if (!vm) {\n      vm = getCurrentInstance() || undefined;\n    }\n    const metaGuards = {\n      removed: []\n    };\n    const resolveContext = {\n      vm\n    };\n    if (this.resolver) {\n      this.resolver.setup(resolveContext);\n    }\n    // TODO: optimize initial compute (once)\n    const meta = this.target.addSource(metadata, resolveContext, true);\n    const onRemoved = removeGuard => metaGuards.removed.push(removeGuard);\n    const unmount = ignoreGuards => this.unmount(!!ignoreGuards, meta, metaGuards, vm);\n    if (vm) {\n      onUnmounted(unmount);\n    }\n    return {\n      meta,\n      onRemoved,\n      unmount\n    };\n  }\n  unmount(ignoreGuards, meta, metaGuards, vm) {\n    if (vm) {\n      const {\n        $el\n      } = vm.proxy;\n      // Wait for element to be removed from DOM\n      if ($el && $el.offsetParent) {\n        let observer = new MutationObserver(records => {\n          for (const {\n            removedNodes\n          } of records) {\n            if (!removedNodes) {\n              continue;\n            }\n            removedNodes.forEach(el => {\n              if (el === $el && observer) {\n                observer.disconnect();\n                observer = undefined;\n                this.reallyUnmount(ignoreGuards, meta, metaGuards);\n              }\n            });\n          }\n        });\n        observer.observe($el.parentNode, {\n          childList: true\n        });\n        return;\n      }\n    }\n    this.reallyUnmount(ignoreGuards, meta, metaGuards);\n  }\n  async reallyUnmount(ignoreGuards, meta, metaGuards) {\n    this.target.delSource(meta);\n    if (!ignoreGuards && metaGuards) {\n      await Promise.all(metaGuards.removed.map(removeGuard => removeGuard()));\n    }\n  }\n  render({\n    slots\n  } = {}) {\n    const teleports = {};\n    for (const key in active) {\n      const config = this.config[key] || {};\n      let renderedNodes = renderMeta({\n        metainfo: active,\n        slots\n      }, key, active[key], config);\n      if (!renderedNodes) {\n        continue;\n      }\n      if (!isArray(renderedNodes)) {\n        renderedNodes = [renderedNodes];\n      }\n      let defaultTo = key !== 'base' && active[key].to;\n      if (!defaultTo && 'to' in config) {\n        defaultTo = config.to;\n      }\n      if (!defaultTo && 'attributesFor' in config) {\n        defaultTo = key;\n      }\n      for (const {\n        to,\n        vnode\n      } of renderedNodes) {\n        addVnode(teleports, to || defaultTo || 'head', vnode);\n      }\n    }\n    if (slots) {\n      for (const slotName in slots) {\n        const tagName = slotName === 'default' ? 'head' : slotName;\n        // Only teleport the contents of head/body slots\n        if (tagName !== 'head' && tagName !== 'body') {\n          continue;\n        }\n        const slot = slots[slotName];\n        if (isFunction(slot)) {\n          addVnode(teleports, tagName, slot({\n            metainfo: active\n          }));\n        }\n      }\n    }\n    return Object.keys(teleports).map(to => {\n      return h(Teleport, {\n        to\n      }, teleports[to]);\n    });\n  }\n}\nMetaManager.create = (config, resolver) => {\n  const resolve = (options, contexts, active, key, pathSegments) => {\n    if (isFunction(resolver)) {\n      return resolver(options, contexts, active, key, pathSegments);\n    }\n    return resolver.resolve(options, contexts, active, key, pathSegments);\n  };\n  const mergedObject = createMergedObject(resolve, active);\n  // TODO: validate resolver\n  const manager = new MetaManager(config, mergedObject, resolver);\n  return manager;\n};\n\n// rollup doesnt like an import as it cant find the export so use require\nconst {\n  renderToString\n} = require('@vue/server-renderer');\nasync function renderToStringWithMeta(app) {\n  const ctx = {};\n  const html = await renderToString(app, ctx);\n  // TODO: better way of determining whether meta was rendered with the component or not\n  if (!ctx.teleports || !ctx.teleports.head) {\n    const teleports = app.config.globalProperties.$metaManager.render();\n    await Promise.all(teleports.map(teleport => renderToString(teleport, ctx)));\n  }\n  const {\n    teleports\n  } = ctx;\n  for (const target in teleports) {\n    if (target.endsWith('Attrs')) {\n      const str = teleports[target];\n      // match from first space to first >, these should be all rendered attributes\n      teleports[target] = str.slice(str.indexOf(' ') + 1, str.indexOf('>'));\n    }\n  }\n  return [html, ctx];\n}\nexport { createMetaManager, deepest as deepestResolver, defaultConfig, getCurrentManager, renderToStringWithMeta, resolveOption, useActiveMeta, useMeta };","map":{"version":3,"names":["markRaw","h","getCurrentInstance","isProxy","watch","inject","defineComponent","reactive","onUnmounted","Teleport","resolveOption","predicament","options","contexts","resolvedIndex","reduce","acc","context","index","retval","undefined","setup","depth","vm","parent","root","resolve","deepest","Object","freeze","__proto__","defaultConfig","body","tag","to","base","valueAttribute","charset","nameless","description","og","group","namespacedAttribute","keyAttribute","twitter","htmlAttrs","attributesFor","headAttrs","bodyAttrs","tags","title","attributes","contentAsAttribute","meta","link","style","script","noscript","getTagConfigItem","tagOrName","key","name","process","env","NODE_ENV","isArray","Array","isFunction","val","isString","isObject","objectToString","prototype","toString","toTypeString","value","call","isPlainObject","IS_PROXY","Symbol","PROXY_SOURCES","PROXY_TARGET","RESOLVE_CONTEXT","clone","v","map","res","pluck","collection","callback","plucked","row","push","allKeys","source","sources","keys","includes","recompute","target","path","length","active","targetKeys","keySources","keyContexts","resolved","createProxy","resolveContext","pathSegments","handler","createHandler","proxy","Proxy","get","receiver","Reflect","keyPath","set","success","isArrayItem","hasArrayParent","proxies","activeSegmentKey","segment","deleteProperty","some","createMergedObject","compute","addSource","delSource","sourceOrProxy","findIndex","src","splice","renderMeta","data","config","renderAttributes","renderGroup","renderTag","console","warn","childKey","groupConfig","namespaced","tagNamespace","namespace","fullName","slotName","flat","contentAttributes","getTagConfig","child","content","hasChilds","isRaw","children","vnode","i","contentAttribute","JSON","stringify","attrs","attr","getSlotContent","tagAttribute","finalTag","innerHTML","metainfo","slots","slot","slotScopeProps","slotContent","hasSymbol","toStringTag","PolySymbol","metaActiveKey","applyDifference","newSource","oldSource","getCurrentManager","appContext","globalProperties","$metaManager","useMeta","manager","Error","metaProxy","addMeta","useActiveMeta","MetainfoImpl","inheritAttrs","_","render","Metainfo","ssrAttribute","addVnode","teleports","vnodes","nodes","endsWith","forEach","props","createMetaManager","resolver","MetaManager","create","constructor","ssrCleanedUp","install","app","component","provide","metadata","metaGuards","removed","onRemoved","removeGuard","unmount","ignoreGuards","$el","offsetParent","observer","MutationObserver","records","removedNodes","el","disconnect","reallyUnmount","observe","parentNode","childList","Promise","all","renderedNodes","defaultTo","tagName","mergedObject","renderToString","require","renderToStringWithMeta","ctx","html","head","teleport","str","slice","indexOf","deepestResolver"],"sources":["C:/Users/ajib/OneDrive/Desktop/event-ticket/New folder/event-ticket-frontend/node_modules/vue-meta/dist/vue-meta.esm-bundler.js"],"sourcesContent":["/**\n * vue-meta v3.0.0-alpha.2\n * (c) 2021\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\nimport { markRaw, h, getCurrentInstance, isProxy, watch, inject, defineComponent, reactive, onUnmounted, Teleport } from 'vue';\n\nconst resolveOption = predicament => (options, contexts) => {\r\n    let resolvedIndex = -1;\r\n    contexts.reduce((acc, context, index) => {\r\n        const retval = predicament(acc, context);\r\n        if (retval !== acc) {\r\n            resolvedIndex = index;\r\n            return retval;\r\n        }\r\n        return acc;\r\n    }, undefined);\r\n    if (resolvedIndex > -1) {\r\n        return options[resolvedIndex];\r\n    }\r\n};\n\nfunction setup(context) {\r\n    let depth = 0;\r\n    if (context.vm) {\r\n        let { vm } = context;\r\n        do {\r\n            if (vm.parent) {\r\n                depth++;\r\n                vm = vm.parent;\r\n            }\r\n        } while (vm && vm.parent && vm !== vm.root);\r\n    }\r\n    context.depth = depth;\r\n}\r\nconst resolve = resolveOption((acc, context) => {\r\n    const { depth } = context;\r\n    if (!acc || depth > acc) {\r\n        return acc;\r\n    }\r\n});\n\nvar deepest = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setup: setup,\n  resolve: resolve\n});\n\nconst defaultConfig = {\r\n    body: {\r\n        tag: 'script',\r\n        to: 'body'\r\n    },\r\n    base: {\r\n        valueAttribute: 'href'\r\n    },\r\n    charset: {\r\n        tag: 'meta',\r\n        nameless: true,\r\n        valueAttribute: 'charset'\r\n    },\r\n    description: {\r\n        tag: 'meta'\r\n    },\r\n    og: {\r\n        group: true,\r\n        namespacedAttribute: true,\r\n        tag: 'meta',\r\n        keyAttribute: 'property'\r\n    },\r\n    twitter: {\r\n        group: true,\r\n        namespacedAttribute: true,\r\n        tag: 'meta'\r\n    },\r\n    htmlAttrs: {\r\n        attributesFor: 'html'\r\n    },\r\n    headAttrs: {\r\n        attributesFor: 'head'\r\n    },\r\n    bodyAttrs: {\r\n        attributesFor: 'body'\r\n    }\r\n};\n\n/*\r\n * This is a fixed config for real HTML tags\r\n */\r\nconst tags = {\r\n    title: {\r\n        attributes: false\r\n    },\r\n    base: {\r\n        contentAsAttribute: true,\r\n        attributes: ['href', 'target']\r\n    },\r\n    meta: {\r\n        contentAsAttribute: true,\r\n        keyAttribute: 'name',\r\n        attributes: ['content', 'name', 'http-equiv', 'charset']\r\n    },\r\n    link: {\r\n        contentAsAttribute: true,\r\n        attributes: [\r\n            'href',\r\n            'crossorigin',\r\n            'rel',\r\n            'media',\r\n            'integrity',\r\n            'hreflang',\r\n            'type',\r\n            'referrerpolicy',\r\n            'sizes',\r\n            'imagesrcset',\r\n            'imagesizes',\r\n            'as',\r\n            'color'\r\n        ]\r\n    },\r\n    style: {\r\n        attributes: ['media']\r\n    },\r\n    script: {\r\n        attributes: [\r\n            'src',\r\n            'type',\r\n            'nomodule',\r\n            'async',\r\n            'defer',\r\n            'crossorigin',\r\n            'integrity',\r\n            'referrerpolicy'\r\n        ]\r\n    },\r\n    noscript: {\r\n        attributes: false\r\n    }\r\n};\n\nfunction getTagConfigItem(tagOrName, key) {\r\n    for (const name of tagOrName) {\r\n        const tag = tags[name];\r\n        if (name && tag) {\r\n            return tag[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\n(process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\n(process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst isArray = Array.isArray;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\n\n// https://github.com/microsoft/TypeScript/issues/1863\r\nconst IS_PROXY = Symbol('kIsProxy');\r\nconst PROXY_SOURCES = Symbol('kProxySources');\r\nconst PROXY_TARGET = Symbol('kProxyTarget');\r\nconst RESOLVE_CONTEXT = Symbol('kResolveContext');\n\n// See: https://github.com/vuejs/vue-next/blob/08b4e8815da4e8911058ccbab986bea6365c3352/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts\r\nfunction clone(v) {\r\n    if (isArray(v)) {\r\n        return v.map(clone);\r\n    }\r\n    if (isObject(v)) {\r\n        const res = {};\r\n        for (const key in v) {\r\n            // never clone the context\r\n            if (key === 'context') {\r\n                res[key] = v[key];\r\n            }\r\n            else {\r\n                res[key] = clone(v[key]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    return v;\r\n}\n\nconst pluck = (collection, key, callback) => {\r\n    const plucked = [];\r\n    for (const row of collection) {\r\n        if (key in row) {\r\n            plucked.push(row[key]);\r\n            if (callback) {\r\n                callback(row);\r\n            }\r\n        }\r\n    }\r\n    return plucked;\r\n};\n\nconst allKeys = (source, ...sources) => {\r\n    const keys = source ? Object.keys(source) : [];\r\n    if (sources) {\r\n        for (const source of sources) {\r\n            if (!source || !isObject(source)) {\r\n                continue;\r\n            }\r\n            for (const key in source) {\r\n                if (!keys.includes(key)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // TODO: add check for consistent types for each key (dev only)\r\n    return keys;\r\n};\r\nconst recompute = (context, sources, target, path = []) => {\r\n    if (!path.length) {\r\n        if (!target) {\r\n            target = context.active;\r\n        }\r\n        if (!sources) {\r\n            sources = context.sources;\r\n        }\r\n    }\r\n    if (!target || !sources) {\r\n        return;\r\n    }\r\n    const keys = allKeys(...sources);\r\n    // Clean up properties that dont exists anymore\r\n    const targetKeys = Object.keys(target);\r\n    for (const key of targetKeys) {\r\n        if (!keys.includes(key)) {\r\n            delete target[key];\r\n        }\r\n    }\r\n    for (const key of keys) {\r\n        // This assumes consistent types usages for keys across sources\r\n        if (isPlainObject(sources[0][key])) {\r\n            if (!target[key]) {\r\n                target[key] = {};\r\n            }\r\n            const keySources = [];\r\n            for (const source of sources) {\r\n                if (key in source) {\r\n                    keySources.push(source[key]);\r\n                }\r\n            }\r\n            recompute(context, keySources, target[key], [...path, key]);\r\n            continue;\r\n        }\r\n        // Ensure the target is an array if source is an array and target is empty\r\n        if (!target[key] && isArray(sources[0][key])) {\r\n            target[key] = [];\r\n        }\r\n        const keyContexts = [];\r\n        const keySources = pluck(sources, key, source => keyContexts.push(source[RESOLVE_CONTEXT]));\r\n        let resolved = context.resolve(keySources, keyContexts, target[key], key, path);\r\n        if (isPlainObject(resolved)) {\r\n            resolved = clone(resolved);\r\n        }\r\n        // console.log('RESOLVED', key, resolved, 'was', target[key])\r\n        target[key] = resolved;\r\n    }\r\n};\n\nconst createProxy = (context, target, resolveContext, pathSegments = []) => {\r\n    const handler = createHandler(context, resolveContext, pathSegments);\r\n    const proxy = markRaw(new Proxy(target, handler));\r\n    if (!pathSegments.length && context.sources) {\r\n        context.sources.push(proxy);\r\n    }\r\n    return proxy;\r\n};\r\nconst createHandler = (context, resolveContext, pathSegments = []) => ({\r\n    get: (target, key, receiver) => {\r\n        if (key === IS_PROXY) {\r\n            return true;\r\n        }\r\n        if (key === PROXY_SOURCES) {\r\n            return context.sources;\r\n        }\r\n        if (key === PROXY_TARGET) {\r\n            return target;\r\n        }\r\n        if (key === RESOLVE_CONTEXT) {\r\n            return resolveContext;\r\n        }\r\n        let value = Reflect.get(target, key, receiver);\r\n        if (!isObject(value)) {\r\n            return value;\r\n        }\r\n        if (!value[IS_PROXY]) {\r\n            const keyPath = [...pathSegments, key];\r\n            value = createProxy(context, value, resolveContext, keyPath);\r\n            target[key] = value;\r\n        }\r\n        return value;\r\n    },\r\n    set: (target, key, value) => {\r\n        const success = Reflect.set(target, key, value);\r\n        // console.warn(success, 'PROXY SET\\nkey:', key, '\\npath:', pathSegments, '\\ntarget:', isArray(target), target, '\\ncontext:\\n', context)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let hasArrayParent = false;\r\n            let { sources: proxies, active } = context;\r\n            let activeSegmentKey;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                proxies = pluck(proxies, segment);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                if (isArray(active)) {\r\n                    hasArrayParent = true;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            if (hasArrayParent) {\r\n                // TODO: fix that we dont have to recompute the full merged object\r\n                // we should only have to recompute the branch that has changed\r\n                // but there is an issue here with supporting both arrays of strings\r\n                // as collections (parent vs parent of parent we need to trigger the\r\n                // update from)\r\n                recompute(context);\r\n                return success;\r\n            }\r\n            let keyContexts = [];\r\n            let keySources;\r\n            if (isArrayItem) {\r\n                keySources = proxies;\r\n                keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n            }\r\n            else {\r\n                keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n            }\r\n            let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n            // Ensure to clone if value is an object, cause sources is an array of\r\n            // the sourceProxies not the sources so we could trigger an endless loop when\r\n            // updating a prop on an obj as the prop on the active object refers to\r\n            // a prop on a proxy\r\n            if (isPlainObject(resolved)) {\r\n                resolved = clone(resolved);\r\n            }\r\n            //      console.log('SET VALUE', isArrayItem, key, '\\nresolved:\\n', resolved, '\\nsources:\\n', context.sources, '\\nactive:\\n', active, Object.keys(active))\r\n            if (isArrayItem && activeSegmentKey) {\r\n                active[activeSegmentKey] = resolved;\r\n            }\r\n            else {\r\n                active[key] = resolved;\r\n            }\r\n        }\r\n        //    console.log('CONTEXT.ACTIVE', context.active, '\\nparent:\\n', target)\r\n        return success;\r\n    },\r\n    deleteProperty: (target, key) => {\r\n        const success = Reflect.deleteProperty(target, key);\r\n        //    console.warn('PROXY DELETE\\nkey:', key, '\\npath:', pathSegments, '\\nparent:', isArray(target), target)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let activeSegmentKey;\r\n            let proxies = context.sources;\r\n            let active = context.active;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                proxies = proxies.map(proxy => proxy[segment]);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            // Check if the key still exists in one of the sourceProxies,\r\n            // if so resolve the new value, if not remove the key\r\n            if (proxies.some(proxy => (key in proxy))) {\r\n                let keyContexts = [];\r\n                let keySources;\r\n                if (isArrayItem) {\r\n                    keySources = proxies;\r\n                    keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n                }\r\n                else {\r\n                    keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n                }\r\n                let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n                if (isPlainObject(resolved)) {\r\n                    resolved = clone(resolved);\r\n                }\r\n                //        console.log('SET VALUE', resolved)\r\n                if (isArrayItem && activeSegmentKey) {\r\n                    active[activeSegmentKey] = resolved;\r\n                }\r\n                else {\r\n                    active[key] = resolved;\r\n                }\r\n            }\r\n            else {\r\n                delete active[key];\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n});\n\nconst createMergedObject = (resolve, active = {}) => {\r\n    const sources = [];\r\n    if (!active) {\r\n        active = {};\r\n    }\r\n    const context = {\r\n        active,\r\n        resolve,\r\n        sources\r\n    };\r\n    const compute = () => recompute(context);\r\n    return {\r\n        context,\r\n        compute,\r\n        addSource: (source, resolveContext, recompute = false) => {\r\n            const proxy = createProxy(context, source, resolveContext || {});\r\n            if (recompute) {\r\n                compute();\r\n            }\r\n            return proxy;\r\n        },\r\n        delSource: (sourceOrProxy, recompute = true) => {\r\n            const index = sources.findIndex(src => src === sourceOrProxy || src[PROXY_TARGET] === sourceOrProxy);\r\n            if (index > -1) {\r\n                sources.splice(index, 1);\r\n                if (recompute) {\r\n                    compute();\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n};\n\nfunction renderMeta(context, key, data, config) {\r\n    // console.info('renderMeta', key, data, config)\r\n    if ('attributesFor' in config) {\r\n        return renderAttributes(context, key, data, config);\r\n    }\r\n    if ('group' in config) {\r\n        return renderGroup(context, key, data, config);\r\n    }\r\n    return renderTag(context, key, data, config);\r\n}\r\nfunction renderGroup(context, key, data, config) {\r\n    // console.info('renderGroup', key, data, config)\r\n    if (isArray(data)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            // eslint-disable-next-line no-console\r\n            console.warn('Specifying an array for group properties isnt supported');\r\n        }\r\n        // config.attributes = getConfigKey([key, config.tag], 'attributes', config)\r\n        return [];\r\n    }\r\n    return Object.keys(data)\r\n        .map((childKey) => {\r\n        const groupConfig = {\r\n            group: key,\r\n            data\r\n        };\r\n        if (config.namespaced) {\r\n            groupConfig.tagNamespace = config.namespaced === true ? key : config.namespaced;\r\n        }\r\n        else if (config.namespacedAttribute) {\r\n            const namespace = config.namespacedAttribute === true ? key : config.namespacedAttribute;\r\n            groupConfig.fullName = `${namespace}:${childKey}`;\r\n            groupConfig.slotName = `${namespace}(${childKey})`;\r\n        }\r\n        return renderTag(context, key, data[childKey], config, groupConfig);\r\n    })\r\n        .flat();\r\n}\r\nfunction renderTag(context, key, data, config = {}, groupConfig) {\r\n    // console.info('renderTag', key, data, config, groupConfig)\r\n    const contentAttributes = ['content', 'json', 'rawContent'];\r\n    const getTagConfig = (key) => getTagConfigItem([tag, config.tag], key);\r\n    if (isArray(data)) {\r\n        return data\r\n            .map((child) => {\r\n            return renderTag(context, key, child, config, groupConfig);\r\n        })\r\n            .flat();\r\n    }\r\n    const { tag = config.tag || key } = data;\r\n    let content = '';\r\n    let hasChilds = false;\r\n    let isRaw = false;\r\n    if (isString(data)) {\r\n        content = data;\r\n    }\r\n    else if (data.children && isArray(data.children)) {\r\n        hasChilds = true;\r\n        content = data.children.map((child) => {\r\n            const data = renderTag(context, key, child, config, groupConfig);\r\n            if (isArray(data)) {\r\n                return data.map(({ vnode }) => vnode);\r\n            }\r\n            return data.vnode;\r\n        });\r\n    }\r\n    else {\r\n        let i = 0;\r\n        for (const contentAttribute of contentAttributes) {\r\n            if (!content && data[contentAttribute]) {\r\n                if (i === 1) {\r\n                    content = JSON.stringify(data[contentAttribute]);\r\n                }\r\n                else {\r\n                    content = data[contentAttribute];\r\n                }\r\n                isRaw = i > 1;\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    const fullName = (groupConfig && groupConfig.fullName) || key;\r\n    const slotName = (groupConfig && groupConfig.slotName) || key;\r\n    let { attrs: attributes } = data;\r\n    if (!attributes && typeof data === 'object') {\r\n        attributes = { ...data };\r\n        delete attributes.tag;\r\n        delete attributes.children;\r\n        delete attributes.to;\r\n        // cleanup all content attributes\r\n        for (const attr of contentAttributes) {\r\n            delete attributes[attr];\r\n        }\r\n    }\r\n    else if (!attributes) {\r\n        attributes = {};\r\n    }\r\n    if (hasChilds) {\r\n        content = getSlotContent(context, slotName, content, data);\r\n    }\r\n    else {\r\n        const contentAsAttribute = !!getTagConfig('contentAsAttribute');\r\n        let { valueAttribute } = config;\r\n        if (!valueAttribute && contentAsAttribute) {\r\n            const [tagAttribute] = getTagConfig('attributes');\r\n            valueAttribute = isString(contentAsAttribute) ? contentAsAttribute : tagAttribute;\r\n        }\r\n        if (!valueAttribute) {\r\n            content = getSlotContent(context, slotName, content, data);\r\n        }\r\n        else {\r\n            const { nameless, keyAttribute } = config;\r\n            if (!nameless) {\r\n                if (keyAttribute) {\r\n                    attributes[keyAttribute] = fullName;\r\n                }\r\n            }\r\n            attributes[valueAttribute] = getSlotContent(context, slotName, attributes[valueAttribute] || content, groupConfig);\r\n            content = '';\r\n        }\r\n    }\r\n    const finalTag = groupConfig && groupConfig.tagNamespace\r\n        ? `${groupConfig.tagNamespace}:${tag}`\r\n        : tag;\r\n    // console.info('FINAL TAG', finalTag)\r\n    // console.log('      ATTRIBUTES', attributes)\r\n    // console.log('      CONTENT', content)\r\n    // // console.log(data, attributes, config)\r\n    if (isRaw && content) {\r\n        attributes.innerHTML = content;\r\n    }\r\n    // Ignore empty string content\r\n    const vnode = h(finalTag, attributes, content || undefined);\r\n    return {\r\n        to: data.to,\r\n        vnode\r\n    };\r\n}\r\nfunction renderAttributes(context, key, data, config) {\r\n    // console.info('renderAttributes', key, data, config)\r\n    const { attributesFor } = config;\r\n    if (!attributesFor) {\r\n        return;\r\n    }\r\n    {\r\n        // render attributes in a placeholder vnode so Vue\r\n        // will render the string for us\r\n        return {\r\n            to: '',\r\n            vnode: h(`ssr-${attributesFor}`, data)\r\n        };\r\n    }\r\n}\r\nfunction getSlotContent({ metainfo, slots }, slotName, content, groupConfig) {\r\n    const slot = slots && slots[slotName];\r\n    if (!slot || !isFunction(slot)) {\r\n        return content;\r\n    }\r\n    const slotScopeProps = {\r\n        content,\r\n        metainfo\r\n    };\r\n    if (groupConfig && groupConfig.group) {\r\n        const { group, data } = groupConfig;\r\n        slotScopeProps[group] = data;\r\n    }\r\n    const slotContent = slot(slotScopeProps);\r\n    if (slotContent && slotContent.length) {\r\n        const { children } = slotContent[0];\r\n        return children ? children.toString() : '';\r\n    }\r\n    return content;\r\n}\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vm = vue meta\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-meta]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-meta]: ' : '_vm_') + name;\r\nconst metaActiveKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'meta_active' : 'ma');\n\n/**\r\n * Apply the differences between newSource & oldSource to target\r\n */\r\nfunction applyDifference(target, newSource, oldSource) {\r\n    for (const key in newSource) {\r\n        if (!(key in oldSource)) {\r\n            target[key] = newSource[key];\r\n            continue;\r\n        }\r\n        // We dont care about nested objects here , these changes\r\n        // should already have been tracked by the MergeProxy\r\n        if (isObject(target[key])) {\r\n            continue;\r\n        }\r\n        if (newSource[key] !== oldSource[key]) {\r\n            target[key] = newSource[key];\r\n        }\r\n    }\r\n    for (const key in oldSource) {\r\n        if (!(key in newSource)) {\r\n            delete target[key];\r\n        }\r\n    }\r\n}\n\nfunction getCurrentManager(vm) {\r\n    if (!vm) {\r\n        vm = getCurrentInstance() || undefined;\r\n    }\r\n    if (!vm) {\r\n        return undefined;\r\n    }\r\n    return vm.appContext.config.globalProperties.$metaManager;\r\n}\r\nfunction useMeta(source, manager) {\r\n    const vm = getCurrentInstance() || undefined;\r\n    if (!manager && vm) {\r\n        manager = getCurrentManager(vm);\r\n    }\r\n    if (!manager) {\r\n        throw new Error('No manager or current instance');\r\n    }\r\n    if (isProxy(source)) {\r\n        watch(source, (newSource, oldSource) => {\r\n            // We only care about first level props, second+ level will already be changed by the merge proxy\r\n            applyDifference(metaProxy.meta, newSource, oldSource);\r\n        });\r\n        source = source.value;\r\n    }\r\n    const metaProxy = manager.addMeta(source, vm);\r\n    return metaProxy;\r\n}\r\nfunction useActiveMeta() {\r\n    return inject(metaActiveKey);\r\n}\n\nconst MetainfoImpl = defineComponent({\r\n    name: 'Metainfo',\r\n    inheritAttrs: false,\r\n    setup(_, { slots }) {\r\n        return () => {\r\n            const manager = getCurrentManager();\r\n            if (!manager) {\r\n                return;\r\n            }\r\n            return manager.render({ slots });\r\n        };\r\n    }\r\n});\r\nconst Metainfo = MetainfoImpl;\n\nconst ssrAttribute = 'data-vm-ssr';\r\nconst active = reactive({});\r\nfunction addVnode(teleports, to, vnodes) {\r\n    const nodes = (isArray(vnodes) ? vnodes : [vnodes]);\r\n    if (!to.endsWith('Attrs')) {\r\n        nodes.forEach((vnode) => {\r\n            if (!vnode.props) {\r\n                vnode.props = {};\r\n            }\r\n            vnode.props[ssrAttribute] = true;\r\n        });\r\n    }\r\n    if (!teleports[to]) {\r\n        teleports[to] = [];\r\n    }\r\n    teleports[to].push(...nodes);\r\n}\r\nconst createMetaManager = (config, resolver) => MetaManager.create(config, resolver);\r\nclass MetaManager {\r\n    constructor(config, target, resolver) {\r\n        this.ssrCleanedUp = false;\r\n        this.config = config;\r\n        this.target = target;\r\n        if (resolver && 'setup' in resolver && isFunction(resolver.setup)) {\r\n            this.resolver = resolver;\r\n        }\r\n    }\r\n    install(app) {\r\n        app.component('Metainfo', Metainfo);\r\n        app.config.globalProperties.$metaManager = this;\r\n        app.provide(metaActiveKey, active);\r\n    }\r\n    addMeta(metadata, vm) {\r\n        if (!vm) {\r\n            vm = getCurrentInstance() || undefined;\r\n        }\r\n        const metaGuards = ({\r\n            removed: []\r\n        });\r\n        const resolveContext = { vm };\r\n        if (this.resolver) {\r\n            this.resolver.setup(resolveContext);\r\n        }\r\n        // TODO: optimize initial compute (once)\r\n        const meta = this.target.addSource(metadata, resolveContext, true);\r\n        const onRemoved = (removeGuard) => metaGuards.removed.push(removeGuard);\r\n        const unmount = (ignoreGuards) => this.unmount(!!ignoreGuards, meta, metaGuards, vm);\r\n        if (vm) {\r\n            onUnmounted(unmount);\r\n        }\r\n        return {\r\n            meta,\r\n            onRemoved,\r\n            unmount\r\n        };\r\n    }\r\n    unmount(ignoreGuards, meta, metaGuards, vm) {\r\n        if (vm) {\r\n            const { $el } = vm.proxy;\r\n            // Wait for element to be removed from DOM\r\n            if ($el && $el.offsetParent) {\r\n                let observer = new MutationObserver((records) => {\r\n                    for (const { removedNodes } of records) {\r\n                        if (!removedNodes) {\r\n                            continue;\r\n                        }\r\n                        removedNodes.forEach((el) => {\r\n                            if (el === $el && observer) {\r\n                                observer.disconnect();\r\n                                observer = undefined;\r\n                                this.reallyUnmount(ignoreGuards, meta, metaGuards);\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                observer.observe($el.parentNode, { childList: true });\r\n                return;\r\n            }\r\n        }\r\n        this.reallyUnmount(ignoreGuards, meta, metaGuards);\r\n    }\r\n    async reallyUnmount(ignoreGuards, meta, metaGuards) {\r\n        this.target.delSource(meta);\r\n        if (!ignoreGuards && metaGuards) {\r\n            await Promise.all(metaGuards.removed.map(removeGuard => removeGuard()));\r\n        }\r\n    }\r\n    render({ slots } = {}) {\r\n        const teleports = {};\r\n        for (const key in active) {\r\n            const config = this.config[key] || {};\r\n            let renderedNodes = renderMeta({ metainfo: active, slots }, key, active[key], config);\r\n            if (!renderedNodes) {\r\n                continue;\r\n            }\r\n            if (!isArray(renderedNodes)) {\r\n                renderedNodes = [renderedNodes];\r\n            }\r\n            let defaultTo = key !== 'base' && active[key].to;\r\n            if (!defaultTo && 'to' in config) {\r\n                defaultTo = config.to;\r\n            }\r\n            if (!defaultTo && 'attributesFor' in config) {\r\n                defaultTo = key;\r\n            }\r\n            for (const { to, vnode } of renderedNodes) {\r\n                addVnode(teleports, to || defaultTo || 'head', vnode);\r\n            }\r\n        }\r\n        if (slots) {\r\n            for (const slotName in slots) {\r\n                const tagName = slotName === 'default' ? 'head' : slotName;\r\n                // Only teleport the contents of head/body slots\r\n                if (tagName !== 'head' && tagName !== 'body') {\r\n                    continue;\r\n                }\r\n                const slot = slots[slotName];\r\n                if (isFunction(slot)) {\r\n                    addVnode(teleports, tagName, slot({ metainfo: active }));\r\n                }\r\n            }\r\n        }\r\n        return Object.keys(teleports).map((to) => {\r\n            return h(Teleport, { to }, teleports[to]);\r\n        });\r\n    }\r\n}\r\nMetaManager.create = (config, resolver) => {\r\n    const resolve = (options, contexts, active, key, pathSegments) => {\r\n        if (isFunction(resolver)) {\r\n            return resolver(options, contexts, active, key, pathSegments);\r\n        }\r\n        return resolver.resolve(options, contexts, active, key, pathSegments);\r\n    };\r\n    const mergedObject = createMergedObject(resolve, active);\r\n    // TODO: validate resolver\r\n    const manager = new MetaManager(config, mergedObject, resolver);\r\n    return manager;\r\n};\n\n// rollup doesnt like an import as it cant find the export so use require\r\nconst { renderToString } = require('@vue/server-renderer');\r\nasync function renderToStringWithMeta(app) {\r\n    const ctx = {};\r\n    const html = await renderToString(app, ctx);\r\n    // TODO: better way of determining whether meta was rendered with the component or not\r\n    if (!ctx.teleports || !ctx.teleports.head) {\r\n        const teleports = app.config.globalProperties.$metaManager.render();\r\n        await Promise.all(teleports.map((teleport) => renderToString(teleport, ctx)));\r\n    }\r\n    const { teleports } = ctx;\r\n    for (const target in teleports) {\r\n        if (target.endsWith('Attrs')) {\r\n            const str = teleports[target];\r\n            // match from first space to first >, these should be all rendered attributes\r\n            teleports[target] = str.slice(str.indexOf(' ') + 1, str.indexOf('>'));\r\n        }\r\n    }\r\n    return [html, ctx];\r\n}\n\nexport { createMetaManager, deepest as deepestResolver, defaultConfig, getCurrentManager, renderToStringWithMeta, resolveOption, useActiveMeta, useMeta };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}